CC = gcc
CFLAGS = -Wall -Wextra -Werror -Wpedantic

MODULE = src/data_module
LIBS = src/data_libs
BIN = bin
APP = $(BIN)/app

OBJS = \
    $(MODULE)/data_module_entry.o \
    $(MODULE)/data_process.o \
    $(LIBS)/data_io.o

all: $(APP)

$(APP): $(OBJS)
	@mkdir -p $(BIN)
	$(CC) $(CFLAGS) $(OBJS) -o $(APP)

$(MODULE)/%.o: $(MODULE)/%.c
	$(CC) $(CFLAGS) -c $< -o $@

$(LIBS)/%.o: $(LIBS)/%.c
	$(CC) $(CFLAGS) -c $< -o $@

clean:
	rm -rf $(OBJS) $(APP) $(BIN)


CC = gcc
CFLAGS = -Wall -Wextra -Werror -Wpedantic

SRC = src
LIBS = $(SRC)/data_libs
MODULE = $(SRC)/data_module
BIN = bin

APP = $(BIN)/app

OBJS = \
    $(MODULE)/data_module_entry.o \
    $(LIBS)/data_process.o \
    $(LIBS)/data_io.o

all: $(APP)

$(APP): $(OBJS)
	@mkdir -p $(BIN)
	$(CC) $(CFLAGS) $(OBJS) -o $(APP)

$(MODULE)/%.o: $(MODULE)/%.c
	$(CC) $(CFLAGS) -c $< -o $@

$(LIBS)/%.o: $(LIBS)/%.c
	$(CC) $(CFLAGS) -c $< -o $@

clean:
	rm -rf $(OBJS) $(APP) $(BIN)


#include <stdio.h>
#include <stdlib.h>
#include "../data_libs/data_process.h"
#include "../data_libs/data_io.h"

int main() {
    double *data = NULL;
    int n = 0;

    if (input(&data, &n)) {
        if (normalization(data, n)) {
            output(data, n);
        } else {
            printf("ERROR");
        }
    } else {
        printf("INPUT ERROR");
    }

    free(data);
    return 0;
}


#include <stdio.h>
#include <stdlib.h>
#include "../data_libs/data_process.h"
#include "../data_libs/data_io.h"

int main() {
    double *data = NULL;
    int n = 0;

    if (input(&data, &n)) {
        if (normalization(data, n)) {
            output(data, n);
        } else {
            printf("ERROR");
        }
    } else {
        printf("INPUT ERROR");
    }

    free(data);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

int input(double **data, int *n) {
    if (scanf("%d", n) != 1 || *n <= 0)
        return 0;

    *data = malloc(*n * sizeof(double));
    if (!*data)
        return 0;

    for (int i = 0; i < *n; i++) {
        if (scanf("%lf", (*data) + i) != 1) {
            free(*data);
            return 0;
        }
    }

    return 1;
}

void output(const double *data, int n) {
    for (int i = 0; i < n; i++) {
        printf("%.2lf ", data[i]);
    }
}
define ROWS 25
#define COLUMNS 80
#define MIN_SPEED 20
#define MAX_SPEED 1000

int work_game();
void render(int mass[ROWS][COLUMNS], int speed);
int check_neighbour(int mass[ROWS][COLUMNS], int i, int j);
void next_step(int mass[ROWS][COLUMNS]);
int handle_input(int *psp);
int read_field(int field[ROWS][COLUMNS]);

int main() {
    return work_game();
}

int work_game() {
    int field[ROWS][COLUMNS];
    int speed = 100;

    // чтение поля из stdin
    if (read_field(field) != 0) {
        printf("n/a\n");
        return 1;
    }

    // перенаправляем stdin обратно на терминал для getch()
    freopen("/dev/tty", "r", stdin);

    // инициализация ncurses
    initscr();
    cbreak();
    noecho();
    nodelay(stdscr, TRUE);

    int running = 1;
    while (running) {
        render(field, speed);         // отрисовка поля и скорости
        next_step(field);             // переход к следующему поколению
        running = handle_input(&speed); // обработка ввода пользователя
        napms(speed);                 // пауза (в миллисекундах)
    }

    endwin(); // завершение ncurses
    return 0;
}

void render(int mass[ROWS][COLUMNS], int speed) {
    clear();
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLUMNS; j++) {
            mvaddch(i, j, mass[i][j] ? '#' : '.');
        }
    }

    // отображение текущей скорости в правом верхнем углу
    mvprintw(0, COLUMNS - 20, "Speed: %d ms", speed);

    // подсказка по управлению (внизу экрана)
    mvprintw(ROWS - 1, 0, "[A] faster  [Z] slower  [SPACE] quit");

    refresh();
}

int check_neighbour(int mass[ROWS][COLUMNS], int i, int j) {
    int count = 0;
    for (int dx = -1; dx <= 1; dx++) {
        for (int dy = -1; dy <= 1; dy++) {
            if (dx == 0 && dy == 0) continue;
            int ni = (i + dx + ROWS) % ROWS;
            int nj = (j + dy + COLUMNS) % COLUMNS;
            count += mass[ni][nj];
        }
    }
    return (mass[i][j] && (count == 2 || count == 3)) || (!mass[i][j] && count == 3);
}

void next_step(int mass[ROWS][COLUMNS]) {
    int new_mass[ROWS][COLUMNS];
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLUMNS; j++) {
            new_mass[i][j] = check_neighbour(mass, i, j);
        }
    }
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLUMNS; j++) {
            mass[i][j] = new_mass[i][j];
        }
    }
}

int handle_input(int *psp) {
    int ch = getch();
    int flag = 1;

    if (ch == ' ') {
        flag = 0; // завершение игры
    }
    if (flag && (ch == 'a' || ch == 'A') && *psp > MIN_SPEED) {
        *psp -= 20; // ускорение
    }
    if (flag && (ch == 'z' || ch == 'Z') && *psp < MAX_SPEED) {
        *psp += 20; // замедление
    }

    return flag;
}

int read_field(int field[ROWS][COLUMNS]) {
    char c;
    int i = 0, j = 0, count = 0, FlagError = 0;

    if (feof(stdin)) {
        FlagError = 1;
    }

    while (!FlagError && (c = getchar()) != EOF) {
        if (c == '0' || c == '1') {
            if (i >= ROWS || j >= COLUMNS) FlagError = 1;
            field[i][j] = c - '0';
            j++;
            count++;
        } else if (c == '\n' || c == '\r') {
            if (j != 0 && j != COLUMNS) FlagError = 1;
            if (j == COLUMNS) { i++; j = 0; }
        } else if (c == ' ' || c == '\t') {
            // пропускаем пробелы и табуляции
        } else {
            FlagError = 1;
        }
    }

    if (j == COLUMNS) i++;
    if (!FlagError && (i != ROWS || count != ROWS * COLUMNS)) FlagError = 1;

    return FlagError;
}

#include <ncurses.h>
#include <stdio.h>
#include <unistd.h>

#define ROWS 25
#define COLUMNS 80
#define MIN_SPEED 20
#define MAX_SPEED 1000

int work_game();
void render(int mass[ROWS][COLUMNS], int speed);
int check_neighbour(int mass[ROWS][COLUMNS], int i, int j);
void next_step(int mass[ROWS][COLUMNS]);
int handle_input(int *psp);
int read_field(int field[ROWS][COLUMNS]);

int main() {
    return work_game();
}

int work_game() {
    int field[ROWS][COLUMNS];
    int speed = 100;

    // чтение поля из stdin
    if (read_field(field) != 0) {
        printf("n/a\n");
        return 1;
    }

    // перенаправляем stdin обратно на терминал для getch()
    freopen("/dev/tty", "r", stdin);

    // инициализация ncurses
    initscr();
    cbreak();
    noecho();
    nodelay(stdscr, TRUE);

    int running = 1;
    while (running) {
        render(field, speed);         // отрисовка поля и скорости
        next_step(field);             // переход к следующему поколению
        running = handle_input(&speed); // обработка ввода пользователя
        napms(speed);                 // пауза (в миллисекундах)
    }

    endwin(); // завершение ncurses
    return 0;
}

void render(int mass[ROWS][COLUMNS], int speed) {
    clear();
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLUMNS; j++) {
            mvaddch(i, j, mass[i][j] ? '#' : '.');
        }
    }

    // отображение текущей скорости в правом верхнем углу
    mvprintw(0, COLUMNS - 20, "Speed: %d ms", speed);

    // подсказка по управлению (внизу экрана)
    mvprintw(ROWS - 1, 0, "[A] faster  [Z] slower  [SPACE] quit");

    refresh();
}

int check_neighbour(int mass[ROWS][COLUMNS], int i, int j) {
    int count = 0;
    for (int dx = -1; dx <= 1; dx++) {
        for (int dy = -1; dy <= 1; dy++) {
            if (dx == 0 && dy == 0) continue;
            int ni = (i + dx + ROWS) % ROWS;
            int nj = (j + dy + COLUMNS) % COLUMNS;
            count += mass[ni][nj];
        }
    }
    return (mass[i][j] && (count == 2 || count == 3)) || (!mass[i][j] && count == 3);
}

void next_step(int mass[ROWS][COLUMNS]) {
    int new_mass[ROWS][COLUMNS];
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLUMNS; j++) {
            new_mass[i][j] = check_neighbour(mass, i, j);
        }
    }
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLUMNS; j++) {
            mass[i][j] = new_mass[i][j];
        }
    }
}

int handle_input(int *psp) {
    int ch = getch();
    int flag = 1;

    if (ch == ' ') {
        flag = 0; // завершение игры
    }
    if (flag && (ch == 'a' || ch == 'A') && *psp > MIN_SPEED) {
        *psp -= 20; // ускорение
    }
    if (flag && (ch == 'z' || ch == 'Z') && *psp < MAX_SPEED) {
        *psp += 20; // замедление
    }

    return flag;
}

int read_field(int field[ROWS][COLUMNS]) {
    char c;
    int i = 0, j = 0, count = 0, FlagError = 0;

    if (feof(stdin)) {
        FlagError = 1;
    }

    while (!FlagError && (c = getchar()) != EOF) {
        if (c == '0' || c == '1') {
            if (i >= ROWS || j >= COLUMNS) FlagError = 1;
            field[i][j] = c - '0';
            j++;
            count++;
        } else if (c == '\n' || c == '\r') {
            if (j != 0 && j != COLUMNS) FlagError = 1;
            if (j == COLUMNS) { i++; j = 0; }
        } else if (c == ' ' || c == '\t') {
            // пропускаем пробелы и табуляции
        } else {
            FlagError =




#include <stdio.h>

#define N 15
#define M 13

void transform(int *buf, int **matr, int n, int m);
void make_picture(int **picture, int n, int m);
void reset_picture(int **picture, int n, int m);
void print_picture(int **picture, int n, int m);

int main(void) {
    int picture_data[N][M];
    int *picture[N];

    transform((int *)picture_data, picture, N, M);
    make_picture(picture, N, M);
    print_picture(picture, N, M);

    return 0;
}

void transform(int *buf, int **matr, int n, int m) {
    for (int i = 0; i < n; i++) {
        matr[i] = buf + i * m;
    }
}

void reset_picture(int **picture, int n, int m) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            picture[i][j] = 0;
        }
    }
}

void make_picture(int **picture, int n, int m) {
    int frame_w[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    int frame_h[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    int tree_trunk[] = {7, 7, 7, 7};
    int tree_foliage[] = {3, 3, 3, 3};
    int sun_data[6][5] = {
        {0, 6, 6, 6, 6},
        {0, 0, 6, 6, 6},
        {0, 0, 6, 6, 6},
        {0, 6, 0, 0, 6},
        {0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0}
    };

    reset_picture(picture, n, m);

    // рамка по краям
    for (int j = 0; j < m; j++) {
        picture[0][j] = 1;
        picture[n - 1][j] = 1;
    }

    for (int i = 0; i < n; i++) {
        picture[i][0] = 1;
        picture[i][m - 1] = 1;
    }

    // солнце (верхний правый угол)
    for (int i = 0; i < 6; i++) {
        for (int j = 0; j < 5; j++) {
            picture[i + 1][j + 8] = sun_data[i][j];
        }
    }

    // дерево (середина слева)
    picture[2][3] = 3;
    picture[2][4] = 3;
    picture[3][2] = 3;
    picture[3][3] = 3;
    picture[3][4] = 3;
    picture[3][5] = 3;
    picture[4][2] = 3;
    picture[4][3] = 3;
    picture[4][4] = 3;
    picture[4][5] = 3;
    picture[5][3] = 3;
    picture[5][4] = 3;

    // ствол дерева
    picture[6][3] = 7;
    picture[6][4] = 7;
    picture[8][3] = 7;
    picture[8][4] = 7;
    picture[9][3] = 7;
    picture[9][4] = 7;
    picture[10][2] = 7;
    picture[10][3] = 7;
    picture[10][4] = 7;
    picture[10][5] = 7;
}

void print_picture(int **picture, int n, int m) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            printf("%d", picture[i][j]);
            if (j < m - 1) {
                printf(" ");
            }
        }
        if (i < n - 1) {
            printf("\n");
        }
    }
}







#include <stdio.h>
#include <sh>

#define MAX_N 100
#define MAX_M 100

int input_static(int **matrix, int *n, int *m);
int input_dynamic_1(int ***matrix, int *n, int *m);
int input_dynamic_2(int ***matrix, int *n, int *m);
int input_dynamic_3(int ***matrix, int *n, int *m);
void transform(int *buf, int **matrix, int n, int m);
void output(int **matrix, int n, int m);
void free_matrix(int **matrix, int n, int type);

int main(void) {
    int *matrix_static[MAX_N];
    int buf_static[MAX_N * MAX_M];
    int **matrix = NULL;
    int n = 0, m = 0, type = 0;
    int success = 1;

    if (scanf("%d", &type) != 1) {
        success = 0;
    }

    if (success) {
        if (type == 1) {
            transform(buf_static, matrix_static, MAX_N, MAX_M);
            success = input_static(matrix_static, &n, &m);
            matrix = matrix_static;
        } else if (type == 2) {
            success = input_dynamic_1(&matrix, &n, &m);
        } else if (type == 3) {
            success = input_dynamic_2(&matrix, &n, &m);
        } else if (type == 4) {
            success = input_dynamic_3(&matrix, &n, &m);
        } else {
            success = 0;
        }
    }

    if (success) {
        output(matrix, n, m);
    } else {
        printf("n/a");
    }

    if (type == 2 || type == 3 || type == 4) {
        free_matrix(matrix, n, type);
    }

    return 0;
}

int input_static(int **matrix, int *n, int *m) {
    int ok = 1, c;
    if (scanf("%d%d", n, m) != 2 || *n <= 0 || *n > MAX_N || *m <= 0 || *m > MAX_M) {
        ok = 0;
    }
    for (int i = 0; i < *n && ok; i++) {
        for (int j = 0; j < *m && ok; j++) {
            if (scanf("%d", &matrix[i][j]) != 1) {
                ok = 0;
            }
        }
    }
    while ((c = getchar()) != '\n' && c != EOF) {
        if (c != ' ' && c != '\t') ok = 0;
    }
    return ok;
}

int input_dynamic_1(int ***matrix, int *n, int *m) {
    int ok = 1, c;
    if (scanf("%d%d", n, m) != 2 || *n <= 0 || *m <= 0) {
        ok = 0;
    }
    if (ok) {
        *matrix = malloc(*n * sizeof(int *));
        if (*matrix == NULL) {
            ok = 0;
        }
    }
    for (int i = 0; i < *n && ok; i++) {
        (*matrix)[i] = malloc(*m * sizeof(int));
        if ((*matrix)[i] == NULL) {
            ok = 0;
        }
    }
    for (int i = 0; i < *n && ok; i++) {
        for (int j = 0; j < *m && ok; j++) {
            if (scanf("%d", &(*matrix)[i][j]) != 1) {
                ok = 0;
            }
        }
    }
    while ((c = getchar()) != '\n' && c != EOF) {
        if (c != ' ' && c != '\t') ok = 0;
    }
    return ok;
}

int input_dynamic_2(int ***matrix, int *n, int *m) {
    int ok = 1, c;
    if (scanf("%d%d", n, m) != 2 || *n <= 0 || *m <= 0) {
        ok = 0;
    }
    if (ok) {
        *matrix = malloc(*n * sizeof(int *) + *n * *m * sizeof(int));
        if (*matrix == NULL) {
            ok = 0;
        }
    }
    if (ok) {
        int *data = (int *)(*matrix + *n);
        for (int i = 0; i < *n; i++) {
            (*matrix)[i] = data + i * (*m);
        }
    }
    for (int i = 0; i < *n && ok; i++) {
        for (int j = 0; j < *m && ok; j++) {
            if (scanf("%d", &(*matrix)[i][j]) != 1) {
                ok = 0;
            }
        }
    }
    while ((c = getchar()) != '\n' && c != EOF) {
        if (c != ' ' && c != '\t') ok = 0;
    }
    return ok;
}

int input_dynamic_3(int ***matrix, int *n, int *m) {
    int ok = 1, c;
    int *buf = NULL;
    if (scanf("%d%d", n, m) != 2 || *n <= 0 || *m <= 0) {
        ok = 0;
    }
    if (ok) {
        *matrix = malloc(*n * sizeof(int *));
        buf = malloc(*n * *m * sizeof(int));
        if (*matrix == NULL || buf == NULL) {
            ok = 0;
        }
    }
    if (ok) {
        transform(buf, *matrix, *n, *m);
        for (int i = 0; i < *n && ok; i++) {
            for (int j = 0; j < *m && ok; j++) {
                if (scanf("%d", &(*matrix)[i][j]) != 1) {
                    ok = 0;
                }
            }
        }
    }
    while ((c = getchar()) != '\n' && c != EOF) {
        if (c != ' ' && c != '\t') ok = 0;
    }
    if (!ok) {
        free(buf);
        free(*matrix);
    }
    return ok;
}

void transform(int *buf, int **matrix, int n, int m) {
    for (int i = 0; i < n; i++) {
        matrix[i] = buf + i * m;
    }
}

void output(int **matrix, int n, int m) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            printf("%d", matrix[i][j]);
            if (j < m - 1) {
                printf(" ");
            }
        }
        if (i < n - 1) {
            printf("\n");
        }
    }
}

void free_matrix(int **matrix, int n, int type) {
    if (type == 2) {
        for (int i = 0; i < n; i++) {
            free(matrix[i]);
        }
        free(matrix);
    } else if (type == 3) {
        free(matrix);
    } else if (type == 4) {
        free(matrix[0]);
        free(matrix);
    }
}
