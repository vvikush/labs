CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -std=c99 -g
BUILD_DIR = build

# Цели (stage names)
.PHONY: all clean door_struct list_test stack_test

# Общая цель
all: door_struct list_test stack_test

# === Квест 1: door_struct ===
DOOR_TARGET = $(BUILD_DIR)/Quest_1
DOOR_SRC = src/dmanager_module.c

door_struct:
	mkdir -p $(BUILD_DIR)
	$(CC) $(CFLAGS) -o $(DOOR_TARGET) $(DOOR_SRC)

# === Квест 2: list_test ===
LIST_TARGET = $(BUILD_DIR)/Quest_2
LIST_SRC = src/list.c src/list_test.c

list_test:
	mkdir -p $(BUILD_DIR)
	$(CC) $(CFLAGS) -o $(LIST_TARGET) $(LIST_SRC)

# === Квест 3: stack_test ===
STACK_TARGET = $(BUILD_DIR)/Quest_3
STACK_SRC = src/stack.c src/stack_test.c

stack_test:
	mkdir -p $(BUILD_DIR)
	$(CC) $(CFLAGS) -o $(STACK_TARGET) $(STACK_SRC)

# Очистка сборки
clean:
	rm -rf $(BUILD_DIR)


#include <stdio.h>
#include "stack.h"

int test_push() {
    struct stack s;
    int result = SUCCESS;

    init(&s);

    if (push(&s, 10) != SUCCESS || s.top == NULL || s.top->value != 10) {
        result = FAIL;
    }

    destroy(&s);
    return result;
}

int test_pop() {
    struct stack s;
    int result = SUCCESS;
    int value = 0;

    init(&s);
    push(&s, 42);

    if (pop(&s, &value) != SUCCESS || value != 42 || s.top != NULL) {
        result = FAIL;
    }

    destroy(&s);
    return result;
}

int main() {
    int result = SUCCESS;

    if (test_push() != SUCCESS) {
        printf("push test failed\n");
        result = FAIL;
    }

    if (test_pop() != SUCCESS) {
        printf("pop test failed\n");
        result = FAIL;
    }

    if (result == SUCCESS) {
        printf("All tests passed\n");
    }

    return result;
}




#include <stdlib.h>
#include "stack.h"

void init(struct stack* s) {
    if (s != NULL) {
        s->top = NULL;
    }
}

int push(struct stack* s, int value) {
    int result = FAIL;
    if (s != NULL) {
        struct stack_node* new_node = malloc(sizeof(struct stack_node));
        if (new_node != NULL) {
            new_node->value = value;
            new_node->next = s->top;
            s->top = new_node;
            result = SUCCESS;
        }
    }
    return result;
}

int pop(struct stack* s, int* value) {
    int result = FAIL;
    if (s != NULL && s->top != NULL && value != NULL) {
        struct stack_node* temp = s->top;
        *value = temp->value;
        s->top = temp->next;
        free(temp);
        result = SUCCESS;
    }
    return result;
}

void destroy(struct stack* s) {
    if (s != NULL) {
        struct stack_node* current = s->top;
        while (current != NULL) {
            struct stack_node* next = current->next;
            free(current);
            current = next;
        }
        s->top = NULL;
    }
}


#ifndef STACK_H
#define STACK_H

#define SUCCESS 0
#define FAIL 1

struct stack_node {
    int value;
    struct stack_node* next;
};

struct stack {
    struct stack_node* top;
};

void init(struct stack* s);
int push(struct stack* s, int value);
int pop(struct stack* s, int* value);
void destroy(struct stack* s);

#endif  // STACK_H




CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -g

# Путь и имя исполняемого файла для door_struct
DOOR_TARGET = build/Quest_1
DOOR_SRC = src/dmanager_module.c

.PHONY: all clean door_struct list_test stack_test

all: door_struct list_test stack_test

door_struct:
	mkdir -p build
	$(CC) $(CFLAGS) -o $(DOOR_TARGET) $(DOOR_SRC)

list_test:
	@echo "Добавь правила сюда позже"

stack_test:
	@echo "Добавь правила сюда позже"

clean:
	rm -rf build


CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -g
TARGET = build/Quest_1
SRC = src/dmanager_module.c

all: $(TARGET)

$(TARGET): $(SRC)
	mkdir -p build
	$(CC) $(CFLAGS) -o $(TARGET) $(SRC)

clean:
	rm -rf build


CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -g
TARGET = build/Quest_1
SRC = src/dmanager_module.c

all: $(TARGET)

$(TARGET): $(SRC)
	mkdir -p build
	$(CC) $(CFLAGS) -o $(TARGET) $(SRC)

clean:
	rm -rf build




#include <stdio.h>
#include <stdlib.h> 
#include <time.h> 
#include "door_struct.h"

#define DOORS_COUNT 15
#define MAX_ID_SEED 10000

void initialize_doors(struct door* doors);

// функция сортировки и закрытия дверей
void sort_and_close_doors(struct door* doors, int count);

int main() {
    struct door doors[DOORS_COUNT];

    initialize_doors(doors);
    sort_and_close_doors(doors, DOORS_COUNT);

    return 0;
}

// Doors initialization function
// ATTENTION!!!
// DO NOT CHANGE!
void initialize_doors(struct door* doors) {
    srand(time(0)); 
    
    int seed = rand() % MAX_ID_SEED;
    for (int i = 0; i < DOORS_COUNT; i++) {
        doors[i].id = (i + seed) % DOORS_COUNT;
        doors[i].status = rand() % 2;
    }
}

// функция сортировки пузырьком и закрытия дверей
void sort_and_close_doors(struct door* doors, int count) {
    int i = 0;
    int j = 0;
    struct door temp;

    for (i = 0; i < count - 1; i++) {
        for (j = 0; j < count - i - 1; j++) {
            if (doors[j].id > doors[j + 1].id) {
                temp = doors[j];
                doors[j] = doors[j + 1];
                doors[j + 1] = temp;
            }
        }
    }

    for (i = 0; i < count; i++) {
        doors[i].status = 0;
        printf("%d, %d\n", doors[i].id, doors[i].status);
    }
}


