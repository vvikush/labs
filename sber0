#ifndef LIST_H
#define LIST_H

#include "door_struct.h"

#define SUCCESS 0
#define FAIL 1

struct node {
    struct door data;
    struct node* next;
};

struct node* init(struct door* door);
struct node* add_door(struct node* elem, struct door* door);
struct node* find_door(int door_id, struct node* root);
struct node* remove_door(struct node* elem, struct node* root);
void destroy(struct node* root);

#endif  // LIST_H

#include <stdlib.h>
#include "list.h"

struct node* init(struct door* door) {
    struct node* new_node = malloc(sizeof(struct node));
    if (new_node != NULL) {
        new_node->data = *door;
        new_node->next = NULL;
    }
    return new_node;
}

struct node* add_door(struct node* elem, struct door* door) {
    if (elem == NULL || door == NULL) return NULL;

    struct node* new_node = malloc(sizeof(struct node));
    if (new_node != NULL) {
        new_node->data = *door;
        new_node->next = elem->next;
        elem->next = new_node;
    }
    return new_node;
}

struct node* find_door(int door_id, struct node* root) {
    struct node* current = root;
    while (current != NULL) {
        if (current->data.id == door_id) {
            break;
        }
        current = current->next;
    }
    return current;
}

struct node* remove_door(struct node* elem, struct node* root) {
    if (root == NULL || elem == NULL) return root;

    if (root == elem) {
        struct node* next = root->next;
        free(root);
        return next;
    }

    struct node* prev = root;
    while (prev->next != NULL && prev->next != elem) {
        prev = prev->next;
    }

    if (prev->next == elem) {
        prev->next = elem->next;
        free(elem);
    }

    return root;
}

void destroy(struct node* root) {
    struct node* current = root;
    while (current != NULL) {
        struct node* next = current->next;
        free(current);
        current = next;
    }
}

#include <stdio.h>
#include "list.h"

int test_add_door() {
    struct door d1 = {1, 1};
    struct door d2 = {2, 1};

    struct node* root = init(&d1);
    if (root == NULL) return FAIL;

    struct node* added = add_door(root, &d2);
    if (added == NULL || root->next != added || added->data.id != 2) {
        destroy(root);
        return FAIL;
    }

    destroy(root);
    return SUCCESS;
}

int test_remove_door() {
    struct door d1 = {1, 1};
    struct door d2 = {2, 1};

    struct node* root = init(&d1);
    if (root == NULL) return FAIL;

    struct node* second = add_door(root, &d2);
    if (second == NULL) {
        destroy(root);
        return FAIL;
    }

    root = remove_door(second, root);  // удалить второй
    if (root == NULL || root->next != NULL) {
        destroy(root);
        return FAIL;
    }

    destroy(root);
    return SUCCESS;
}

int main() {
    int result = SUCCESS;

    if (test_add_door() != SUCCESS) {
        printf("add_door test failed\n");
        result = FAIL;
    }

    if (test_remove_door() != SUCCESS) {
        printf("remove_door test failed\n");
        result = FAIL;
    }

    if (result == SUCCESS) {
        printf("All tests passed\n");
    }

    return result;
}


CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -std=c99 -g
BUILD_DIR = build

# Цели (stage names)
.PHONY: all clean door_struct list_test stack_test

# Общая цель
all: door_struct list_test stack_test

# === Квест 1: door_struct ===
DOOR_TARGET = $(BUILD_DIR)/Quest_1
DOOR_SRC = src/dmanager_module.c

door_struct:
	mkdir -p $(BUILD_DIR)
	$(CC) $(CFLAGS) -o $(DOOR_TARGET) $(DOOR_SRC)

# === Квест 2: list_test ===
LIST_TARGET = $(BUILD_DIR)/Quest_2
LIST_SRC = src/list.c src/list_test.c

list_test:
	mkdir -p $(BUILD_DIR)
	$(CC) $(CFLAGS) -o $(LIST_TARGET) $(LIST_SRC)

# === Квест 3: stack_test ===
STACK_TARGET = $(BUILD_DIR)/Quest_3
STACK_SRC = src/stack.c src/stack_test.c

stack_test:
	mkdir -p $(BUILD_DIR)
	$(CC) $(CFLAGS) -o $(STACK_TARGET) $(STACK_SRC)

# Очистка сборки
clean:
	rm -rf $(BUILD_DIR)


#include <stdio.h>
#include "stack.h"

int test_push() {
    struct stack s;
    int result = SUCCESS;

    init(&s);

    if (push(&s, 10) != SUCCESS || s.top == NULL || s.top->value != 10) {
        result = FAIL;
    }

    destroy(&s);
    return result;
}

int test_pop() {
    struct stack s;
    int result = SUCCESS;
    int value = 0;

    init(&s);
    push(&s, 42);

    if (pop(&s, &value) != SUCCESS || value != 42 || s.top != NULL) {
        result = FAIL;
    }

    destroy(&s);
    return result;
}

int main() {
    int result = SUCCESS;

    if (test_push() != SUCCESS) {
        printf("push test failed\n");
        result = FAIL;
    }

    if (test_pop() != SUCCESS) {
        printf("pop test failed\n");
        result = FAIL;
    }

    if (result == SUCCESS) {
        printf("All tests passed\n");
    }

    return result;
}




#include <stdlib.h>
#include "stack.h"

void init(struct stack* s) {
    if (s != NULL) {
        s->top = NULL;
    }
}

int push(struct stack* s, int value) {
    int result = FAIL;
    if (s != NULL) {
        struct stack_node* new_node = malloc(sizeof(struct stack_node));
        if (new_node != NULL) {
            new_node->value = value;
            new_node->next = s->top;
            s->top = new_node;
            result = SUCCESS;
        }
    }
    return result;
}

int pop(struct stack* s, int* value) {
    int result = FAIL;
    if (s != NULL && s->top != NULL && value != NULL) {
        struct stack_node* temp = s->top;
        *value = temp->value;
        s->top = temp->next;
        free(temp);
        result = SUCCESS;
    }
    return result;
}

void destroy(struct stack* s) {
    if (s != NULL) {
        struct stack_node* current = s->top;
        while (current != NULL) {
            struct stack_node* next = current->next;
            free(current);
            current = next;
        }
        s->top = NULL;
    }
}


#ifndef STACK_H
#define STACK_H

#define SUCCESS 0
#define FAIL 1

struct stack_node {
    int value;
    struct stack_node* next;
};

struct stack {
    struct stack_node* top;
};

void init(struct stack* s);
int push(struct stack* s, int value);
int pop(struct stack* s, int* value);
void destroy(struct stack* s);

#endif  // STACK_H




CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -g

# Путь и имя исполняемого файла для door_struct
DOOR_TARGET = build/Quest_1
DOOR_SRC = src/dmanager_module.c

.PHONY: all clean door_struct list_test stack_test

all: door_struct list_test stack_test

door_struct:
	mkdir -p build
	$(CC) $(CFLAGS) -o $(DOOR_TARGET) $(DOOR_SRC)

list_test:
	@echo "Добавь правила сюда позже"

stack_test:
	@echo "Добавь правила сюда позже"

clean:
	rm -rf build


CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -g
TARGET = build/Quest_1
SRC = src/dmanager_module.c

all: $(TARGET)

$(TARGET): $(SRC)
	mkdir -p build
	$(CC) $(CFLAGS) -o $(TARGET) $(SRC)

clean:
	rm -rf build


CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -g
TARGET = build/Quest_1
SRC = src/dmanager_module.c

all: $(TARGET)

$(TARGET): $(SRC)
	mkdir -p build
	$(CC) $(CFLAGS) -o $(TARGET) $(SRC)

clean:
	rm -rf build




#include <stdio.h>
#include <stdlib.h> 
#include <time.h> 
#include "door_struct.h"

#define DOORS_COUNT 15
#define MAX_ID_SEED 10000

void initialize_doors(struct door* doors);

// функция сортировки и закрытия дверей
void sort_and_close_doors(struct door* doors, int count);

int main() {
    struct door doors[DOORS_COUNT];

    initialize_doors(doors);
    sort_and_close_doors(doors, DOORS_COUNT);

    return 0;
}

// Doors initialization function
// ATTENTION!!!
// DO NOT CHANGE!
void initialize_doors(struct door* doors) {
    srand(time(0)); 
    
    int seed = rand() % MAX_ID_SEED;
    for (int i = 0; i < DOORS_COUNT; i++) {
        doors[i].id = (i + seed) % DOORS_COUNT;
        doors[i].status = rand() % 2;
    }
}

// функция сортировки пузырьком и закрытия дверей
void sort_and_close_doors(struct door* doors, int count) {
    int i = 0;
    int j = 0;
    struct door temp;

    for (i = 0; i < count - 1; i++) {
        for (j = 0; j < count - i - 1; j++) {
            if (doors[j].id > doors[j + 1].id) {
                temp = doors[j];
                doors[j] = doors[j + 1];
                doors[j + 1] = temp;
            }
        }
    }

    for (i = 0; i < count; i++) {
        doors[i].status = 0;
        printf("%d, %d\n", doors[i].id, doors[i].status);
    }
}


