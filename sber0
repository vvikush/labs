#include <stdio.h>
#include <math.h>

#define WIDTH 80
#define HEIGHT 25
#define CENTER_Y 12
#define PI 3.14159265358979323846

// заглушка — позже будет заменена на реальную реализацию вычислений f(x)
double evaluate(double x) {
    return sin(x);  // временно просто sin(x)
}

void draw_graph() {
    char field[HEIGHT][WIDTH];

    // заполняем всё поле точками
    for (int row = 0; row < HEIGHT; row++) {
        for (int col = 0; col < WIDTH; col++) {
            field[row][col] = '.';
        }
    }

    // проходим по всем 80 точкам X
    for (int col = 0; col < WIDTH; col++) {
        // вычисляем значение x от 0 до 4π
        double x = (4.0 * PI * col) / (WIDTH - 1);
        double y = evaluate(x);

        // проверка: y должен быть в диапазоне [-1, 1]
        if (y < -1.0 || y > 1.0) {
            continue; // за пределами допустимого — пропускаем
        }

        // округляем y по математическим правилам в координату row
        int row = CENTER_Y - (int)round(y * (HEIGHT / 2.0 - 1));

        // проверка границ
        if (row >= 0 && row < HEIGHT) {
            field[row][col] = '*';
        }
    }

    // выводим поле в терминал
    for (int row = 0; row < HEIGHT; row++) {
        for (int col = 0; col < WIDTH; col++) {
            putchar(field[row][col]);
        }
        putchar('\n');
    }
}



int test_find_door_found() {
    struct door d1 = {100, 1};
    struct door d2 = {200, 1};

    struct node* root = init(&d1);
    if (root == NULL) return FAIL;

    add_door(root, &d2);

    struct node* found = find_door(200, root);
    if (found == NULL || found->data.id != 200) {
        destroy(root);
        return FAIL;
    }

    destroy(root);
    return SUCCESS;
}

int test_find_door_not_found() {
    struct door d1 = {100, 1};
    struct node* root = init(&d1);
    if (root == NULL) return FAIL;

    struct node* found = find_door(999, root);
    if (found != NULL) {
        destroy(root);
        return FAIL;
    }

    destroy(root);
    return SUCCESS;
}


if (test_find_door_found() != SUCCESS) {
    printf("find_door_found test failed\n");
    result = FAIL;
}

if (test_find_door_not_found() != SUCCESS) {
    printf("find_door_not_found test failed\n");
    result = FAIL;
}

#include <stdlib.h>
#include "list.h"

struct node* init(struct door* door) {
    struct node* new_node = NULL;

    if (door != NULL) {
        new_node = malloc(sizeof(struct node));
        if (new_node != NULL) {
            new_node->data = *door;
            new_node->next = NULL;
        }
    }

    return new_node;
}

struct node* add_door(struct node* elem, struct door* door) {
    struct node* new_node = NULL;

    if (elem != NULL && door != NULL) {
        new_node = malloc(sizeof(struct node));
        if (new_node != NULL) {
            new_node->data = *door;
            new_node->next = elem->next;
            elem->next = new_node;
        }
    }

    return new_node;
}

struct node* find_door(int door_id, struct node* root) {
    struct node* current = root;

    while (current != NULL) {
        if (current->data.id == door_id) {
            break;
        }
        current = current->next;
    }

    return current;
}

struct node* remove_door(struct node* elem, struct node* root) {
    struct node* new_root = root;

    if (elem != NULL && root != NULL) {
        if (root == elem) {
            new_root = root->next;
            free(root);
        } else {
            struct node* prev = root;
            while (prev->next != NULL && prev->next != elem) {
                prev = prev->next;
            }

            if (prev->next == elem) {
                prev->next = elem->next;
                free(elem);
            }
        }
    }

    return new_root;
}

void destroy(struct node* root) {
    struct node* current = root;
    struct node* next = NULL;

    while (current != NULL) {
        next = current->next;
        free(current);
        current = next;
    }
}



#ifndef LIST_H
#define LIST_H

#include "door_struct.h"

#define SUCCESS 0
#define FAIL 1

struct node {
    struct door data;
    struct node* next;
};

struct node* init(struct door* door);
struct node* add_door(struct node* elem, struct door* door);
struct node* find_door(int door_id, struct node* root);
struct node* remove_door(struct node* elem, struct node* root);
void destroy(struct node* root);

#endif  // LIST_H

#include <stdlib.h>
#include "list.h"

struct node* init(struct door* door) {
    struct node* new_node = malloc(sizeof(struct node));
    if (new_node != NULL) {
        new_node->data = *door;
        new_node->next = NULL;
    }
    return new_node;
}

struct node* add_door(struct node* elem, struct door* door) {
    if (elem == NULL || door == NULL) return NULL;

    struct node* new_node = malloc(sizeof(struct node));
    if (new_node != NULL) {
        new_node->data = *door;
        new_node->next = elem->next;
        elem->next = new_node;
    }
    return new_node;
}

struct node* find_door(int door_id, struct node* root) {
    struct node* current = root;
    while (current != NULL) {
        if (current->data.id == door_id) {
            break;
        }
        current = current->next;
    }
    return current;
}

struct node* remove_door(struct node* elem, struct node* root) {
    if (root == NULL || elem == NULL) return root;

    if (root == elem) {
        struct node* next = root->next;
        free(root);
        return next;
    }

    struct node* prev = root;
    while (prev->next != NULL && prev->next != elem) {
        prev = prev->next;
    }

    if (prev->next == elem) {
        prev->next = elem->next;
        free(elem);
    }

    return root;
}

void destroy(struct node* root) {
    struct node* current = root;
    while (current != NULL) {
        struct node* next = current->next;
        free(current);
        current = next;
    }
}

#include <stdio.h>
#include "list.h"

int test_add_door() {
    struct door d1 = {1, 1};
    struct door d2 = {2, 1};

    struct node* root = init(&d1);
    if (root == NULL) return FAIL;

    struct node* added = add_door(root, &d2);
    if (added == NULL || root->next != added || added->data.id != 2) {
        destroy(root);
        return FAIL;
    }

    destroy(root);
    return SUCCESS;
}

int test_remove_door() {
    struct door d1 = {1, 1};
    struct door d2 = {2, 1};

    struct node* root = init(&d1);
    if (root == NULL) return FAIL;

    struct node* second = add_door(root, &d2);
    if (second == NULL) {
        destroy(root);
        return FAIL;
    }

    root = remove_door(second, root);  // удалить второй
    if (root == NULL || root->next != NULL) {
        destroy(root);
        return FAIL;
    }

    destroy(root);
    return SUCCESS;
}

int main() {
    int result = SUCCESS;

    if (test_add_door() != SUCCESS) {
        printf("add_door test failed\n");
        result = FAIL;
    }

    if (test_remove_door() != SUCCESS) {
        printf("remove_door test failed\n");
        result = FAIL;
    }

    if (result == SUCCESS) {
        printf("All tests passed\n");
    }

    return result;
}


CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -std=c99 -g
BUILD_DIR = build

# Цели (stage names)
.PHONY: all clean door_struct list_test stack_test

# Общая цель
all: door_struct list_test stack_test

# === Квест 1: door_struct ===
DOOR_TARGET = $(BUILD_DIR)/Quest_1
DOOR_SRC = src/dmanager_module.c

door_struct:
	mkdir -p $(BUILD_DIR)
	$(CC) $(CFLAGS) -o $(DOOR_TARGET) $(DOOR_SRC)

# === Квест 2: list_test ===
LIST_TARGET = $(BUILD_DIR)/Quest_2
LIST_SRC = src/list.c src/list_test.c

list_test:
	mkdir -p $(BUILD_DIR)
	$(CC) $(CFLAGS) -o $(LIST_TARGET) $(LIST_SRC)

# === Квест 3: stack_test ===
STACK_TARGET = $(BUILD_DIR)/Quest_3
STACK_SRC = src/stack.c src/stack_test.c

stack_test:
	mkdir -p $(BUILD_DIR)
	$(CC) $(CFLAGS) -o $(STACK_TARGET) $(STACK_SRC)

# Очистка сборки
clean:
	rm -rf $(BUILD_DIR)


#include <stdio.h>
#include "stack.h"

int test_push() {
    struct stack s;
    int result = SUCCESS;

    init(&s);

    if (push(&s, 10) != SUCCESS || s.top == NULL || s.top->value != 10) {
        result = FAIL;
    }

    destroy(&s);
    return result;
}

int test_pop() {
    struct stack s;
    int result = SUCCESS;
    int value = 0;

    init(&s);
    push(&s, 42);

    if (pop(&s, &value) != SUCCESS || value != 42 || s.top != NULL) {
        result = FAIL;
    }

    destroy(&s);
    return result;
}

int main() {
    int result = SUCCESS;

    if (test_push() != SUCCESS) {
        printf("push test failed\n");
        result = FAIL;
    }

    if (test_pop() != SUCCESS) {
        printf("pop test failed\n");
        result = FAIL;
    }

    if (result == SUCCESS) {
        printf("All tests passed\n");
    }

    return result;
}




#include <stdlib.h>
#include "stack.h"

void init(struct stack* s) {
    if (s != NULL) {
        s->top = NULL;
    }
}

int push(struct stack* s, int value) {
    int result = FAIL;
    if (s != NULL) {
        struct stack_node* new_node = malloc(sizeof(struct stack_node));
        if (new_node != NULL) {
            new_node->value = value;
            new_node->next = s->top;
            s->top = new_node;
            result = SUCCESS;
        }
    }
    return result;
}

int pop(struct stack* s, int* value) {
    int result = FAIL;
    if (s != NULL && s->top != NULL && value != NULL) {
        struct stack_node* temp = s->top;
        *value = temp->value;
        s->top = temp->next;
        free(temp);
        result = SUCCESS;
    }
    return result;
}

void destroy(struct stack* s) {
    if (s != NULL) {
        struct stack_node* current = s->top;
        while (current != NULL) {
            struct stack_node* next = current->next;
            free(current);
            current = next;
        }
        s->top = NULL;
    }
}


#ifndef STACK_H
#define STACK_H

#define SUCCESS 0
#define FAIL 1

struct stack_node {
    int value;
    struct stack_node* next;
};

struct stack {
    struct stack_node* top;
};

void init(struct stack* s);
int push(struct stack* s, int value);
int pop(struct stack* s, int* value);
void destroy(struct stack* s);

#endif  // STACK_H




CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -g

# Путь и имя исполняемого файла для door_struct
DOOR_TARGET = build/Quest_1
DOOR_SRC = src/dmanager_module.c

.PHONY: all clean door_struct list_test stack_test

all: door_struct list_test stack_test

door_struct:
	mkdir -p build
	$(CC) $(CFLAGS) -o $(DOOR_TARGET) $(DOOR_SRC)

list_test:
	@echo "Добавь правила сюда позже"

stack_test:
	@echo "Добавь правила сюда позже"

clean:
	rm -rf build


CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -g
TARGET = build/Quest_1
SRC = src/dmanager_module.c

all: $(TARGET)

$(TARGET): $(SRC)
	mkdir -p build
	$(CC) $(CFLAGS) -o $(TARGET) $(SRC)

clean:
	rm -rf build


CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -g
TARGET = build/Quest_1
SRC = src/dmanager_module.c

all: $(TARGET)

$(TARGET): $(SRC)
	mkdir -p build
	$(CC) $(CFLAGS) -o $(TARGET) $(SRC)

clean:
	rm -rf build




#include <stdio.h>
#include <stdlib.h> 
#include <time.h> 
#include "door_struct.h"

#define DOORS_COUNT 15
#define MAX_ID_SEED 10000

void initialize_doors(struct door* doors);

// функция сортировки и закрытия дверей
void sort_and_close_doors(struct door* doors, int count);

int main() {
    struct door doors[DOORS_COUNT];

    initialize_doors(doors);
    sort_and_close_doors(doors, DOORS_COUNT);

    return 0;
}

// Doors initialization function
// ATTENTION!!!
// DO NOT CHANGE!
void initialize_doors(struct door* doors) {
    srand(time(0)); 
    
    int seed = rand() % MAX_ID_SEED;
    for (int i = 0; i < DOORS_COUNT; i++) {
        doors[i].id = (i + seed) % DOORS_COUNT;
        doors[i].status = rand() % 2;
    }
}

// функция сортировки пузырьком и закрытия дверей
void sort_and_close_doors(struct door* doors, int count) {
    int i = 0;
    int j = 0;
    struct door temp;

    for (i = 0; i < count - 1; i++) {
        for (j = 0; j < count - i - 1; j++) {
            if (doors[j].id > doors[j + 1].id) {
                temp = doors[j];
                doors[j] = doors[j + 1];
                doors[j + 1] = temp;
            }
        }
    }

    for (i = 0; i < count; i++) {
        doors[i].status = 0;
        printf("%d, %d\n", doors[i].id, doors[i].status);
    }
}


